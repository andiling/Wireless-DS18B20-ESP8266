#include <Arduino.h> //for byte type
#include <ESP8266WiFi.h>
#include <FS.h>

#include "WirelessDS18B20.h"

#include "WebCore.h"



//------------------------------------------
//simple function that convert an hexadecimal char to byte
byte WebCore::AsciiToHex(char c) {
  return (c < 0x3A) ? (c - 0x30) : (c > 0x60 ? c - 0x57 : c - 0x37);
}

//------------------------------------------
// Function that lookup in Datas to find a parameter and then return the corresponding decoded value
String WebCore::FindParameterInURLEncodedDatas(String datas, String parameterToFind) {

  String res = "";

  //can we find the param in the url
  int posParam = datas.indexOf(parameterToFind + "=");

  //if not then return empty string
  if (posParam == -1) return res;

  //if previous char is not a separator then lookup for the next match
  if (posParam != 0 && datas[posParam - 1] != '&') return FindParameterInURLEncodedDatas(datas.substring(posParam + parameterToFind.length()), parameterToFind);

  //now we can extract the value and decode it at the same time
  //adujst position to the start of the value
  posParam += parameterToFind.length() + 1;
  while (posParam < datas.length() && datas[posParam] != '&') {
    if (datas[posParam] == '+') res += ' ';
    else if (datas[posParam] == '%') {
      res += (char)(AsciiToHex(datas[posParam + 1]) * 0x10 + AsciiToHex(datas[posParam + 2]));
      posParam++;
      posParam++;
    }
    else res += datas[posParam];
    posParam++;
  }
  return res;
}

//------------------------------------------
//function that send to Web Client a standard answer (like error or simple success)
void WebCore::SendHTTPResponse(WiFiClient c, int code, ContentType ct, const char* content, uint16_t goToRefererTimeOut) {

  char goToRefererTimeOutA[7];
  uint16_t headerLength = 0;
  uint16_t contentLength = 0;
  char contentLengthA[7];

  //size calculations ---------------------

  //calculate ContentLength
  if (content) contentLength = strlen(content);
  if (goToRefererTimeOut) {
    itoa(goToRefererTimeOut, goToRefererTimeOutA, 10);
    contentLength += 103 + strlen(goToRefererTimeOutA); //103 is size of script function
  }

  //calculate headerlength
  headerLength = 9; // HTTP/1.1
  //200 OK or 404 Not Found ...
  switch (code) {
    case 200: headerLength += 6; break;
    case 400: headerLength += 15; break;
    case 404: headerLength += 13; break;
    case 500: headerLength += 25; break;
    default: return; //other code not accepted yet
  }

  //Content-Type
  if (ct != no) {
    headerLength += 16;
    switch (ct) {
      case html: headerLength += 9; break;
      case json: headerLength += 9; break;
    }
  }

  //rest of header (expires, content-length, etc...)
  headerLength += 53;
  itoa(contentLength, contentLengthA, 10); //convert contentLength to text
  headerLength += strlen(contentLengthA);

  //Sending response ---------------------

  char respBuf[std::max(headerLength, (uint16_t)(103 + strlen(goToRefererTimeOutA))) + 1]; //create buffer of sufficient size

  strcpy_P(respBuf, PSTR("HTTP/1.1 "));
  switch (code) {
    case 200: strcat_P(respBuf, PSTR("200 OK")); break;
    case 400: strcat_P(respBuf, PSTR("400 Bad Request")); break;
    case 404: strcat_P(respBuf, PSTR("404 Not Found")); break;
    case 500: strcat_P(respBuf, PSTR("500 Internal Server Error")); break;
    default: return; //other code not accepted yet
  }

  if (ct != no) {

    strcat_P(respBuf, PSTR("\r\nContent-Type: "));
    switch (ct) {
      case html:
        strcat_P(respBuf, PSTR("text/html"));
        break;
      case json:
        strcat_P(respBuf, PSTR("text/json"));
        break;
    }
  }
  sprintf_P(respBuf, PSTR("%s\r\nExpires: 0\r\nConnection: close\r\nContent-Length: %s\r\n\r\n"), respBuf, contentLengthA);
  c.write((uint8_t *)respBuf, strlen(respBuf));

  if (content && strlen(content)) c.write(content, strlen(content));
  if (goToRefererTimeOut) {
    sprintf_P(respBuf, PSTR("<script>setTimeout(function(){if('referrer' in document)window.location=document.referrer;},%s);</script>"), goToRefererTimeOutA);
    c.write((uint8_t *)respBuf, strlen(respBuf));
  }
}
//------------------------------------------
//function that send to Web Client a standard answer (like error or simple success)
void WebCore::SendHTTPResponse(WiFiClient c, int code, ContentType ct, const __FlashStringHelper* content, uint16_t goToRefererTimeOut) {

  const char* _content = (const char*)content;

  char goToRefererTimeOutA[7];
  uint16_t headerLength = 0;
  uint16_t contentLength = 0;
  char contentLengthA[7];

  //size calculations ---------------------

  //calculate ContentLength
  if (_content) contentLength = strlen_P(_content);
  if (goToRefererTimeOut) {
    itoa(goToRefererTimeOut, goToRefererTimeOutA, 10);
    contentLength += 103 + strlen(goToRefererTimeOutA); //103 is size of script function
  }

  //calculate headerlength
  headerLength = 9; // HTTP/1.1
  //200 OK or 404 Not Found ...
  switch (code) {
    case 200: headerLength += 6; break;
    case 400: headerLength += 15; break;
    case 404: headerLength += 13; break;
    case 500: headerLength += 25; break;
    default: return; //other code not accepted yet
  }

  //Content-Type
  if (ct != no) {
    headerLength += 16;
    switch (ct) {
      case html: headerLength += 9; break;
      case json: headerLength += 9; break;
    }
  }

  //rest of header (expires, content-length, etc...)
  headerLength += 53;
  itoa(contentLength, contentLengthA, 10); //convert contentLength to text
  headerLength += strlen(contentLengthA);

  //Sending response ---------------------

  //NEXT_ESP_VERSION
  //char respBuf[std::max(headerLength, (uint16_t)(103 + strlen(goToRefererTimeOutA))) + 1]; //create buffer of sufficient size
  char respBuf[std::max(std::max(headerLength, (uint16_t)(103 + strlen(goToRefererTimeOutA))), (uint16_t)strlen_P(_content)) + 1]; //create buffer of sufficient size

  strcpy_P(respBuf, PSTR("HTTP/1.1 "));
  switch (code) {
    case 200: strcat_P(respBuf, PSTR("200 OK")); break;
    case 400: strcat_P(respBuf, PSTR("400 Bad Request")); break;
    case 404: strcat_P(respBuf, PSTR("404 Not Found")); break;
    case 500: strcat_P(respBuf, PSTR("500 Internal Server Error")); break;
    default: return; //other code not accepted yet
  }

  if (ct != no) {

    strcat_P(respBuf, PSTR("\r\nContent-Type: "));
    switch (ct) {
      case html:
        strcat_P(respBuf, PSTR("text/html"));
        break;
      case json:
        strcat_P(respBuf, PSTR("text/json"));
        break;
    }
  }
  sprintf_P(respBuf, PSTR("%s\r\nExpires: 0\r\nConnection: close\r\nContent-Length: %s\r\n\r\n"), respBuf, contentLengthA);
  c.write((uint8_t *)respBuf, strlen(respBuf));

  //NEXT_ESP_VERSION
  //if (content && strlen_P(_content)) c.write(_content, strlen_P(_content));
  if (content && strlen_P(_content)) {
    strcpy_P(respBuf, _content);
    c.write((uint8_t *)respBuf, strlen(respBuf));
  }
  if (goToRefererTimeOut) {
    sprintf_P(respBuf, PSTR("<script>setTimeout(function(){if('referrer' in document)window.location=document.referrer;},%s);</script>"), goToRefererTimeOutA);
    c.write((uint8_t *)respBuf, strlen(respBuf));
  }
}




const PROGMEM bool gz = true;
const PROGMEM char fwhtmlgz[] = {0x1F, 0x8B, 0x08, 0x08, 0xB2, 0xFC, 0xAA, 0x58, 0x02, 0x00, 0x66, 0x77, 0x2E, 0x68, 0x74, 0x6D, 0x6C, 0x00, 0xBD, 0x58, 0xE9, 0x8E, 0xD3, 0x30, 0x10, 0xFE, 0x8F, 0xC4, 0x3B, 0x98, 0x00, 0x72, 0xC2, 0x42, 0x42, 0xCB, 0x21, 0xE8, 0x85, 0x38, 0xC5, 0x22, 0x4E, 0x15, 0x84, 0x10, 0xF0, 0xC3, 0x4D, 0x26, 0xAD, 0xC1, 0x71, 0x82, 0xED, 0x6C, 0x29, 0x88, 0x77, 0x67, 0xEC, 0xA4, 0x69, 0x68, 0x9B, 0x8A, 0xBB, 0x88, 0x5D, 0x5F, 0x33, 0xF3, 0xCD, 0x37, 0xE3, 0x19, 0x77, 0x47, 0x67, 0xEE, 0x3D, 0xBB, 0xFB, 0xF2, 0xCD, 0xF3, 0xFB, 0x64, 0x61, 0x32, 0x31, 0x39, 0x7D, 0x6A, 0x54, 0xFF, 0x26, 0xF8, 0x19, 0x2D, 0x80, 0x25, 0xF5, 0xD8, 0xCD, 0x33, 0x30, 0x8C, 0xC4, 0x0B, 0xA6, 0x34, 0x98, 0xB1, 0x57, 0x9A, 0xF4, 0xD2, 0x0D, 0xAF, 0xBD, 0x6F, 0xB8, 0x11, 0x30, 0x79, 0x74, 0xFD, 0x0E, 0x79, 0xCD, 0x15, 0x08, 0xD0, 0x9A, 0xDC, 0x9B, 0xF6, 0x6E, 0xDC, 0xE9, 0x5F, 0x1E, 0x45, 0x6E, 0x6F, 0xAD, 0x38, 0x6A, 0x69, 0x1E, 0xCD, 0xF2, 0x64, 0x45, 0xB4, 0x59, 0x09, 0x18, 0x7B, 0x33, 0x16, 0x7F, 0x9C, 0xAB, 0xBC, 0x94, 0xC9, 0xA5, 0x38, 0x17, 0xB9, 0x1A, 0x90, 0xB3, 0x69, 0x9A, 0xCC, 0x6E, 0xDE, 0x1C, 0x92, 0xBB, 0xF5, 0xFC, 0xB2, 0xFB, 0x0C, 0xD3, 0x5C, 0x9A, 0x4B, 0x29, 0xCB, 0xB8, 0x58, 0x0D, 0xC8, 0x6D, 0xC5, 0x99, 0x18, 0xFE, 0x80, 0x65, 0xD1, 0xEB, 0x00, 0x82, 0x1B, 0xED, 0x63, 0xFD, 0xB5, 0xE9, 0x84, 0xEB, 0x42, 0xB0, 0xD5, 0x80, 0x4B, 0xC1, 0x25, 0x78, 0x93, 0x07, 0x5C, 0x65, 0x4B, 0xA6, 0x80, 0x3C, 0x61, 0x92, 0xCD, 0x21, 0x03, 0x69, 0xC8, 0x73, 0x1C, 0xA0, 0x86, 0xFE, 0x64, 0xA4, 0x0B, 0x26, 0x09, 0x4F, 0xC6, 0x9E, 0xE8, 0x79, 0x93, 0x03, 0x5A, 0x46, 0xB3, 0x09, 0x79, 0x9C, 0xB3, 0x84, 0xCB, 0x79, 0x18, 0x86, 0xA3, 0x68, 0x36, 0xA9, 0xE4, 0x23, 0xAB, 0x00, 0x81, 0xB4, 0xA1, 0x5C, 0x99, 0xBC, 0x2A, 0x04, 0x9E, 0x25, 0x8C, 0x48, 0x58, 0x92, 0x06, 0xC0, 0xC0, 0x12, 0x76, 0xA5, 0x8D, 0x3A, 0xCD, 0x55, 0xE6, 0xAC, 0xA7, 0x3D, 0x8F, 0x60, 0x54, 0x16, 0x79, 0x32, 0xA6, 0xCF, 0x9F, 0x4D, 0x5F, 0x52, 0xC2, 0x62, 0xC3, 0x73, 0x39, 0xA6, 0x51, 0xBA, 0xA4, 0x04, 0x64, 0x6C, 0x56, 0x05, 0x8C, 0x69, 0x56, 0x0A, 0xC3, 0x0B, 0xA6, 0x4C, 0x64, 0x45, 0x2F, 0x25, 0xCC, 0x30, 0x4A, 0x72, 0xA9, 0xCB, 0x59, 0xC6, 0xCD, 0x98, 0x2A, 0x30, 0xA5, 0x92, 0x24, 0xCE, 0x65, 0x8A, 0x46, 0x7D, 0xEF, 0x36, 0x5A, 0x5D, 0xE5, 0x25, 0xD1, 0x25, 0x0E, 0x4C, 0x4E, 0x52, 0xC1, 0xF4, 0x82, 0xA4, 0x35, 0xA0, 0x5B, 0x5E, 0x30, 0xA4, 0x35, 0x9C, 0x06, 0x12, 0x97, 0x45, 0x69, 0x48, 0x65, 0x2D, 0xE5, 0x02, 0x28, 0x91, 0x2C, 0x73, 0xE3, 0x1E, 0x45, 0xA8, 0x38, 0xE8, 0x59, 0x70, 0x31, 0x14, 0x68, 0x2F, 0x9C, 0x71, 0x79, 0x50, 0x43, 0x05, 0x8C, 0x92, 0x13, 0x26, 0x4A, 0x9C, 0x46, 0x67, 0xDE, 0x91, 0x8A, 0x9B, 0x0D, 0x2B, 0xB8, 0x46, 0xC9, 0x96, 0x8E, 0x26, 0x2C, 0x54, 0xF5, 0xE8, 0x86, 0xE4, 0x66, 0xDB, 0x79, 0xDF, 0xCD, 0xFA, 0x6B, 0x98, 0xA1, 0x7E, 0x71, 0x88, 0x71, 0x9A, 0xF6, 0x69, 0x17, 0xE3, 0x65, 0x71, 0x98, 0xF1, 0x5F, 0xE0, 0xAC, 0x6F, 0x39, 0x73, 0x83, 0x5F, 0xA1, 0xA9, 0xA1, 0x08, 0x55, 0x75, 0x33, 0xD3, 0xEF, 0x66, 0x66, 0xB3, 0xD0, 0xDA, 0x9A, 0xA9, 0x09, 0xFE, 0xC7, 0xBD, 0x5D, 0x5D, 0xC9, 0x4A, 0x4E, 0x71, 0x4C, 0xEB, 0xEC, 0xA7, 0xEB, 0xEC, 0x27, 0x32, 0x97, 0xB0, 0x93, 0x23, 0xD3, 0xE7, 0xC7, 0x0F, 0x1E, 0x4C, 0x49, 0xA9, 0x21, 0x89, 0x4C, 0x6E, 0x98, 0x20, 0x9A, 0x7F, 0x41, 0xB2, 0x5B, 0x0A, 0xCB, 0x06, 0x1B, 0x89, 0x5A, 0xCB, 0xA6, 0x59, 0xDE, 0x20, 0x69, 0x47, 0xD0, 0x05, 0x4D, 0x70, 0x6D, 0xC8, 0x60, 0x23, 0x24, 0xFA, 0xB4, 0x7D, 0xF7, 0x6A, 0x05, 0x36, 0xB0, 0x3B, 0x1A, 0xAE, 0x3A, 0x0D, 0xBA, 0x0D, 0xC5, 0x93, 0x33, 0x6F, 0x72, 0x65, 0x23, 0x74, 0x75, 0x5B, 0xC8, 0xB0, 0x99, 0x80, 0x2A, 0x4A, 0xC2, 0xC2, 0x73, 0xF3, 0xD6, 0xA1, 0x7D, 0x57, 0x5C, 0xC7, 0x8A, 0x17, 0x86, 0x68, 0x15, 0x8F, 0xBD, 0xE8, 0xC3, 0xA7, 0x12, 0xD4, 0xEA, 0xD2, 0x95, 0xB0, 0x87, 0xFF, 0x32, 0x2E, 0xC3, 0x0F, 0xDA, 0xAB, 0xE2, 0xEA, 0x19, 0xF8, 0x6C, 0xA2, 0x0F, 0xEC, 0x84, 0x55, 0x02, 0x1E, 0xAA, 0xAF, 0x46, 0x93, 0x1D, 0x65, 0x5B, 0xB0, 0x78, 0x4A, 0xFC, 0x33, 0x4B, 0x2E, 0x93, 0x7C, 0x19, 0x7E, 0x78, 0x61, 0x0D, 0x04, 0x5F, 0xF1, 0xC4, 0xD6, 0x27, 0xC9, 0xE3, 0xD2, 0x16, 0xB4, 0x70, 0xA9, 0xB8, 0x01, 0x9F, 0xD6, 0xBA, 0x3A, 0xAC, 0x57, 0x78, 0x17, 0xC6, 0x14, 0x7A, 0x10, 0x45, 0xEC, 0x03, 0xFB, 0x1C, 0x32, 0x5D, 0x48, 0x30, 0x71, 0x22, 0xC3, 0x38, 0xCF, 0xDC, 0x52, 0x54, 0x59, 0xDB, 0xE7, 0x15, 0xC2, 0x7F, 0xB7, 0xC6, 0x4F, 0x83, 0xE1, 0x01, 0x38, 0x73, 0x30, 0xF7, 0x05, 0xD8, 0xE1, 0x9D, 0xD5, 0x71, 0xE2, 0x53, 0xD1, 0xA3, 0x41, 0xC8, 0xA5, 0x04, 0xF5, 0xF0, 0xE5, 0x93, 0xC7, 0x63, 0x8A, 0x91, 0xEA, 0x2A, 0xB4, 0xC4, 0x7F, 0xE4, 0x00, 0x10, 0x7B, 0x05, 0x20, 0x21, 0xA9, 0xCA, 0x33, 0x72, 0x2C, 0x0D, 0x28, 0x04, 0x1A, 0xB8, 0x00, 0xD2, 0x2D, 0xD3, 0xDF, 0x7E, 0x9C, 0x82, 0xD0, 0x40, 0xCE, 0xF9, 0xDE, 0x59, 0x2C, 0xE9, 0x41, 0x98, 0xA2, 0x96, 0x67, 0xA5, 0xF1, 0xDB, 0x78, 0xFF, 0x24, 0x0A, 0xE4, 0xEB, 0xBF, 0xF2, 0xFB, 0xCE, 0xED, 0xE9, 0xF1, 0x5D, 0xF2, 0xE4, 0xD9, 0xBD, 0xFB, 0xDB, 0x6E, 0x6E, 0x3E, 0x4C, 0x80, 0x32, 0x3E, 0x6D, 0x51, 0x44, 0x52, 0xC6, 0x05, 0x24, 0x21, 0x79, 0x75, 0x4C, 0xB8, 0x26, 0x5C, 0x92, 0x19, 0xD3, 0x3C, 0x26, 0x59, 0x9E, 0x40, 0x48, 0x83, 0x4E, 0xAA, 0x0E, 0x93, 0xF0, 0xA3, 0x54, 0x5A, 0x4A, 0x57, 0x1B, 0x89, 0x82, 0x54, 0x81, 0x5E, 0x3C, 0x78, 0xEC, 0xEF, 0xCB, 0xC6, 0xDD, 0x15, 0x17, 0x85, 0x7E, 0x1D, 0x85, 0x63, 0x89, 0x41, 0xD8, 0x7F, 0x26, 0x15, 0x78, 0xC6, 0xBE, 0x58, 0x30, 0x85, 0x0D, 0x96, 0x29, 0xB3, 0xB0, 0x0D, 0xD7, 0x96, 0x52, 0x5B, 0x48, 0xAB, 0x6E, 0x8B, 0x6B, 0xF5, 0x3A, 0x56, 0x9B, 0xAD, 0xB5, 0xC8, 0xFD, 0x40, 0x49, 0xBA, 0xD7, 0x82, 0x8D, 0xCB, 0xA3, 0xE9, 0xB3, 0xA7, 0xBE, 0x17, 0xA1, 0xA5, 0x8B, 0x8D, 0x3F, 0xBE, 0xAD, 0x16, 0x8F, 0xB9, 0x36, 0xE8, 0x4D, 0xED, 0xF2, 0xAE, 0x2C, 0xB0, 0x78, 0xD1, 0x1C, 0xBC, 0xD8, 0x88, 0x7E, 0xBC, 0x78, 0xB2, 0xCB, 0x41, 0x3B, 0x73, 0xFC, 0x8F, 0x67, 0x5C, 0x49, 0x09, 0xD0, 0x43, 0x7A, 0x96, 0x1E, 0x7D, 0xAC, 0x3D, 0x3C, 0xD9, 0x82, 0xB8, 0x89, 0x4D, 0xD7, 0xC6, 0x4F, 0x21, 0x0B, 0x53, 0xB1, 0x01, 0xC7, 0x0F, 0x82, 0xDB, 0x50, 0xCE, 0x8A, 0x02, 0x64, 0xE2, 0x7B, 0x6B, 0xD2, 0xBD, 0xA3, 0x93, 0x50, 0x1E, 0x79, 0x96, 0xCF, 0x66, 0xAE, 0x5B, 0xF3, 0x1F, 0x9A, 0xD6, 0xAC, 0x34, 0x26, 0x97, 0xB4, 0x6A, 0x20, 0x33, 0xEF, 0x88, 0x1F, 0x79, 0x4D, 0x07, 0xBB, 0x07, 0x02, 0x0C, 0xD0, 0x4D, 0x64, 0x5C, 0xC1, 0xC7, 0xF7, 0xC6, 0x61, 0x50, 0x4E, 0x4D, 0x10, 0xC6, 0x82, 0xC7, 0x1F, 0xFD, 0xC6, 0x1B, 0x38, 0x31, 0x9D, 0xDE, 0xB4, 0x43, 0xEC, 0xD3, 0x48, 0x65, 0xB7, 0xB0, 0x83, 0x1F, 0x81, 0x8E, 0x59, 0x01, 0x3E, 0x3A, 0x13, 0xA0, 0x93, 0x62, 0xC9, 0x56, 0xDA, 0x6F, 0x72, 0xF7, 0x10, 0x88, 0x6F, 0xBF, 0x1C, 0x9C, 0x4D, 0x8A, 0xEF, 0x16, 0x9A, 0x6E, 0xE9, 0x6F, 0xC3, 0xCE, 0x3B, 0x56, 0x35, 0xFF, 0xE7, 0x2A, 0x9F, 0x23, 0x5C, 0x84, 0xDD, 0xE5, 0xFA, 0x09, 0x53, 0xE4, 0xF3, 0x42, 0x91, 0x31, 0x3A, 0x6F, 0x0B, 0xF7, 0x14, 0x8C, 0xC1, 0x0E, 0xA9, 0x43, 0x5C, 0xF4, 0x03, 0xD2, 0x01, 0x17, 0x37, 0xC3, 0xD2, 0x59, 0x08, 0x73, 0x59, 0xD4, 0x46, 0x50, 0xC7, 0x8F, 0x64, 0x13, 0x55, 0xDF, 0xC6, 0x63, 0x49, 0xD6, 0x48, 0xF0, 0x6A, 0x61, 0x56, 0xDB, 0xFD, 0x50, 0x80, 0x9C, 0x9B, 0xC5, 0xDD, 0x3C, 0x2B, 0x4A, 0xD7, 0x2D, 0xB1, 0x28, 0xAA, 0x75, 0x2E, 0x51, 0x6C, 0xBE, 0xF4, 0xC8, 0x9D, 0x72, 0x05, 0x3C, 0xB2, 0x43, 0xF7, 0x4A, 0xB8, 0xD0, 0xBB, 0x7C, 0xF9, 0x88, 0x9E, 0x47, 0x3D, 0xDF, 0x86, 0xE4, 0x5B, 0x17, 0xC0, 0xFA, 0x09, 0x8B, 0x38, 0xBB, 0x28, 0xDB, 0xA4, 0xB0, 0xAD, 0xEF, 0xD5, 0xD3, 0xE9, 0x60, 0xB2, 0x58, 0x04, 0x85, 0x82, 0x13, 0x90, 0xE6, 0x1E, 0xA4, 0xAC, 0x14, 0x3B, 0x41, 0xAA, 0x29, 0xF4, 0xF7, 0x50, 0x5D, 0x2A, 0x31, 0x70, 0x8F, 0xF0, 0x8B, 0x36, 0xEB, 0x07, 0xD5, 0x5B, 0xF1, 0x62, 0x8C, 0x57, 0x0F, 0x06, 0x24, 0x65, 0x42, 0xC3, 0xC5, 0x38, 0x97, 0x06, 0x75, 0xBF, 0x5C, 0x15, 0xCD, 0x12, 0x32, 0x1B, 0x23, 0x67, 0xF7, 0x98, 0x61, 0xEB, 0xA5, 0x3D, 0x6D, 0xC3, 0xEE, 0xBA, 0x6F, 0x08, 0xB9, 0xCA, 0xEC, 0x51, 0xDF, 0x56, 0x8A, 0x14, 0x7B, 0xC6, 0xDB, 0xCB, 0xEF, 0x83, 0x5D, 0x01, 0x4B, 0xCA, 0x60, 0x13, 0xA9, 0xE0, 0xAB, 0xE3, 0x6A, 0x3B, 0x63, 0x9C, 0x12, 0x85, 0x4A, 0x90, 0xE7, 0x3D, 0x3A, 0x74, 0x19, 0x5B, 0x64, 0x83, 0x46, 0x4D, 0x72, 0x51, 0x1F, 0x4A, 0x31, 0x05, 0x56, 0x79, 0xEF, 0x9A, 0x86, 0x78, 0xDC, 0xF4, 0xB9, 0x58, 0x01, 0x33, 0x50, 0xB7, 0x3A, 0x9F, 0x56, 0x6D, 0x83, 0x76, 0x5C, 0x91, 0xB6, 0x8A, 0xD0, 0xBE, 0x49, 0xC6, 0xD4, 0x2A, 0x8E, 0xF3, 0x52, 0x9A, 0x71, 0xEF, 0xEA, 0xD0, 0x4D, 0x12, 0x3E, 0xD6, 0x60, 0x5C, 0x9F, 0xC7, 0x12, 0xE2, 0xB7, 0x9C, 0xB4, 0x91, 0x8E, 0x13, 0x2F, 0x70, 0xA2, 0xBE, 0x93, 0x0A, 0x86, 0x98, 0x88, 0x67, 0xAA, 0xE1, 0xD7, 0x58, 0x00, 0x53, 0x8D, 0x20, 0x2A, 0x0A, 0x86, 0x22, 0x8F, 0x99, 0x95, 0x0E, 0x2B, 0xCB, 0x3E, 0x32, 0xE1, 0x0E, 0x5F, 0xBA, 0x84, 0x94, 0x60, 0x16, 0x5E, 0x0E, 0x86, 0xB4, 0x03, 0x6B, 0x4D, 0x5E, 0xD3, 0x8D, 0xDC, 0x33, 0xB2, 0x6E, 0xD9, 0xF5, 0x37, 0x59, 0x64, 0x19, 0xE4, 0xD0, 0x7D, 0x25, 0xBC, 0x97, 0x4B, 0xDB, 0x89, 0x9A, 0xB7, 0xEE, 0x74, 0xA5, 0x0D, 0x64, 0xB6, 0x0F, 0x2B, 0x98, 0xE5, 0xB9, 0xB1, 0x2F, 0x56, 0xF2, 0x72, 0x81, 0xF3, 0x82, 0xCD, 0x81, 0x2C, 0xB9, 0x10, 0x64, 0x06, 0x35, 0x21, 0x90, 0x10, 0x2E, 0x5B, 0x0F, 0x55, 0x74, 0x72, 0xD2, 0xBB, 0x56, 0xAB, 0xB2, 0x5C, 0xD1, 0xA6, 0x40, 0xB7, 0x18, 0xEC, 0x22, 0x79, 0x9D, 0x3A, 0xA1, 0x51, 0x7C, 0x3E, 0x07, 0xE5, 0x53, 0x05, 0x1A, 0xF6, 0x07, 0x65, 0x5F, 0x5E, 0x80, 0x52, 0xE8, 0x5C, 0x8B, 0xF7, 0xDF, 0xE6, 0x47, 0x41, 0x52, 0xB1, 0xF3, 0xC0, 0xBD, 0x4C, 0x5A, 0xFC, 0xD0, 0xBF, 0x02, 0x1E, 0x97, 0x3A, 0x4A, 0x2B, 0x4E, 0x76, 0x8B, 0x44, 0xFF, 0xAF, 0x15, 0x09, 0xE7, 0x7B, 0x1F, 0x51, 0x42, 0x56, 0x98, 0x95, 0x8F, 0x6A, 0x17, 0xF9, 0xD2, 0x9D, 0xFA, 0xB5, 0x62, 0x52, 0x16, 0xFF, 0xAF, 0x98, 0xF4, 0xFF, 0x46, 0x31, 0xE9, 0xFF, 0x69, 0x31, 0xD9, 0xB0, 0xF7, 0x9B, 0x37, 0x8B, 0x6E, 0xFA, 0xEB, 0x35, 0xBC, 0xBF, 0x07, 0xF3, 0xA8, 0xDF, 0x95, 0x47, 0xBB, 0x9F, 0xCD, 0x7B, 0xF6, 0x5F, 0x5C, 0x93, 0xFE, 0x6F, 0x5C, 0x93, 0x3F, 0x77, 0xF6, 0xCF, 0x2F, 0xCD, 0xBA, 0xCC, 0x07, 0xA1, 0x02, 0x96, 0xAC, 0xFC, 0x2E, 0x6F, 0xDD, 0xFD, 0xAA, 0xFF, 0x74, 0xD0, 0xF1, 0xC6, 0xEF, 0xE4, 0xD8, 0x19, 0xED, 0xFC, 0x32, 0x82, 0x64, 0xE4, 0xC9, 0x0A, 0x27, 0xA3, 0xC8, 0x12, 0x38, 0xF9, 0x0E, 0x9F, 0x92, 0x88, 0x56, 0xDF, 0x14, 0x00, 0x00};
//------------------------------------------
//native webpage that implement Firmware Update and file management
void WebCore::GetFirmwarePage(WiFiClient c) {
  char respBuf[83];
  //send header
  strcpy_P(respBuf, PSTR("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nExpires: 0\r\n"));
  if (gz) strcat_P(respBuf, PSTR("Content-Encoding: gzip\r\n"));
  strcat_P(respBuf, PSTR("\r\n"));
  c.write((uint8_t *)respBuf, strlen(respBuf));
  //send native firmware page
  c.write_P(fwhtmlgz, sizeof(fwhtmlgz));
}
//------------------------------------------
//Provide a JSON list of file and infos about FS
void WebCore::GetFileList(WiFiClient c) {

  FSInfo fs_info;
  SPIFFS.info(fs_info);
  byte nbElement = 0;

  String flJSON = String(F("{\"t\":")) + fs_info.totalBytes + F(",\"u\":") + fs_info.usedBytes + F(",\"fl\":[");

  Dir dir = SPIFFS.openDir("/");
  bool first = true;

  while (dir.next()) {

    File entry = dir.openFile("r");
    flJSON += String(!first ? "," : "") + F("{\"t\":\"f\",\"n\":\"") + entry.name() + F("\",\"s\":") + entry.size() + F("}");
    entry.close();
    nbElement++;
    first = false;
  }
  flJSON = flJSON + F("],\"nb\":") + nbElement + '}';

  SendHTTPResponse(c, 200, json, flJSON.c_str());
}
//------------------------------------------
//Parse GET request then call handleFileRead to return the file to Web Client
void WebCore::GetFile(WiFiClient c, String &req) {
  req = req.substring(4, req.indexOf(F(" HTTP/1."))); //isolate filename
  req.replace(F("%20"), " "); //only url encoded space is accepted
  ReadFile(req, c);
}

//------------------------------------------
//Manage HTTP discussion in order to receive a POSTed file
void WebCore::PostFile(WiFiClient c, bool firmwareUpdate) {
  String tmp = "";
  String header = "";
  byte boundarySize = 0;
  int i, j;
  long contentLength = 0;
  String filename = "";


  //read complete header (until empty line is found) -----
  tmp = c.readStringUntil('\n');
  while (tmp != "\r") {
    header += tmp;
    tmp = c.readStringUntil('\n');
  }

  //find boundary then it's size
  i = header.indexOf(F("boundary=")) + 9;
  j = i;
  while (header[j] != '\r' && j < header.length()) j++;
  boundarySize = j - i;


  //find Content-Length and extract it (converted to long)
  i = header.indexOf(F("Content-Length")) + 14;
  if (header[i] == ' ' || header[i] == ':') i++;
  if (header[i] == ' ' || header[i] == ':') i++;
  j = i;
  while (header[j] >= '0' && header[j] <= '9' && j < header.length()) j++;
  tmp = header.substring(i, j);
  contentLength = tmp.toInt();

  //end of page is marked with a CRLF, boundary with 4 minuses and another CRLF
  contentLength -= boundarySize + 2 + 4 + 2;

  //check for empty POST
  if (contentLength <= 0) {
    SendHTTPResponse(c, 400, html, F("Missing File Content!"));
    return;
  }

  //read complete boundary header (until empty line is found) -----
  tmp = c.readStringUntil('\n');
  contentLength -= tmp.length() + 1;
  while (tmp != "\r") {
    header += tmp;
    tmp = c.readStringUntil('\n');
    contentLength -= tmp.length() + 1;
  }

  if (!firmwareUpdate) {

    //look for filename
    i = header.indexOf("filename=") + 9;
    if (header[i] == '\"') i++;
    j = i;
    while (header[j] != '\"' && header[j] != '\r' && j < header.length()) j++;
    filename = header.substring(i, j);

    if (filename[0] != '/') filename = "/" + filename; //if first / is missing

    if (SPIFFS.exists(filename)) {
      SendHTTPResponse(c, 400, html, F("File Already exists"));
      return;
    }

    FSInfo fs_info;
    SPIFFS.info(fs_info);
    if (fs_info.totalBytes <= (fs_info.usedBytes + contentLength + 64)) {
      while (contentLength) {
        c.read(); //waste datas
        contentLength--;
      };
      SendHTTPResponse(c, 400, html, F("Not enough place on destination storage"));
      return;
    }
  }

  //empty String
  header = String();
  tmp = String();

  if (firmwareUpdate) WriteFirmware(contentLength, c);
  else WriteFile(filename, contentLength, c);
}
//------------------------------------------
//Parse GET request to remove a file
void WebCore::GetRemoveFile(WiFiClient c, String &req) {

  String tmp = "";
  String header = "";
  int i, j;

  //check request structure
  if (req.indexOf('?') == -1 || req.indexOf(F("? ")) != -1 || req.indexOf(F(" HTTP/")) == -1) {
    SendHTTPResponse(c, 400, html, F("Missing parameter"));
    return;
  }
  //keep only the part after '?' and before the final HTTP/1.1
  String getDatas = req.substring(req.indexOf('?') + 1, req.indexOf(F(" HTTP/")));

  String filename = FindParameterInURLEncodedDatas(getDatas, F("n"));

  //check filename passed
  if (filename[filename.length() - 1] == '/') {
    SendHTTPResponse(c, 400, html, F("Can't Remove Folder"));
    return;
  }

  //check that file exists
  if (!SPIFFS.exists(filename)) {
    SendHTTPResponse(c, 400, html, F("This file does not exist"));
    return;
  }

  //read complete header (until empty line is found) ---
  tmp = c.readStringUntil('\n');
  while (tmp != "\r") {
    header += tmp;
    tmp = c.readStringUntil('\n');
  }

  //empty String
  header = String();
  tmp = String();

  DeleteFile(filename, c);
}

//------------------------------------------
//return system Status
void WebCore::GetSystemStatus(WiFiClient c) {

  unsigned long minutes = millis() / 60000;

  String ssJSON = F("{\"b\":\"");
  ssJSON = ssJSON + VERSION + F("\",\"u\":\"") + (byte)(minutes / 1440) + 'd' + (byte)(minutes / 60 % 24) + 'h' + (byte)(minutes % 60) + F("m\",\"f\":") + ESP.getFreeHeap() + '}';

  SendHTTPResponse(c, 200, json, ssJSON.c_str());
}











//------------------------------------------
//Return Content-Type based on filename
String WebCore::getContentType(String &filename) {
  /*if (server.hasArg("download")) return F("application/octet-stream");
    else */if (filename.endsWith(".htm")) return F("text/html");
  else if (filename.endsWith(".html")) return F("text/html");
  else if (filename.endsWith(".css")) return F("text/css");
  else if (filename.endsWith(".js")) return F("application/javascript");
  //else if (filename.endsWith(".png")) return F("image/png");
  //else if (filename.endsWith(".gif")) return F("image/gif");
  //else if (filename.endsWith(".jpg")) return F("image/jpeg");
  else if (filename.endsWith(".ico")) return F("image/x-icon");
  //else if (filename.endsWith(".xml")) return F("text/xml");
  //else if (filename.endsWith(".pdf")) return F("application/x-pdf");
  //else if (filename.endsWith(".zip")) return F("application/x-zip");
  else if (filename.endsWith(".gz")) return F("application/x-gzip");
  return F("text/plain");
}
//------------------------------------------
//Open the file then return content to Web Client
void WebCore::ReadFile(String &path, WiFiClient c) {

  char respBuf[1400];

  //if no extension then add .html
  if (path.indexOf('.') == -1) path += F(".html");
  String contentType = getContentType(path);
  size_t sent = 0;
  if (SPIFFS.exists(path) || SPIFFS.exists(path + F(".gz"))) {
    if (SPIFFS.exists(path + F(".gz"))) path += F(".gz");

    File file = SPIFFS.open(path, "r");
    if (file) {

      //prepare and send header
      strcpy_P(respBuf, PSTR("HTTP/1.1 200 OK\r\nContent-Type: "));
      strcat(respBuf, contentType.c_str());
      if (String(file.name()).endsWith(".gz") && contentType != "application/x-gzip" && contentType != "application/octet-stream") {
        strcat_P(respBuf, PSTR("\r\nContent-Encoding: gzip"));
      }
      strcat_P(respBuf, PSTR("\r\n\r\n"));
      c.write((uint8_t *)respBuf, strlen(respBuf));


      int siz = file.size();
      while (siz > 0) {
        size_t len = std::min((int)(sizeof(respBuf) - 1), siz);
        file.read((uint8_t *)respBuf, len);
        sent += c.write((uint8_t *)respBuf, len);
        siz -= len;
      }

      //sent = c.write(file);
      file.close();
    }
  }

  if (sent == 0) {
    SendHTTPResponse(c, 404);
  }
}

//------------------------------------------
//Create file and fill it with Web Client datas
void WebCore::WriteFile(String &path, long fileSize, WiFiClient c) {

  char reqBuf[1024];

  File fsUploadFile = SPIFFS.open(path, "w");

  while (fileSize > 0) {
    size_t len = (fileSize >= sizeof(reqBuf)) ? sizeof(reqBuf) : fileSize;

    //wait for enough byte in c buffer
    int waited = 1000;
    while (c.available() < len && waited--) delay(1);

    //if waited more than 1 second
    if (!waited) {
      //then fail
      SendHTTPResponse(c, 500, html, F("File Upload Error : Network Timeout"));
      fsUploadFile.close();
      SPIFFS.remove(path);
      return;
    }

    c.read((uint8_t*)reqBuf, len);
    fsUploadFile.write((uint8_t*)reqBuf, len);
    fileSize -= len;
  }
  fsUploadFile.close();

  if (fileSize == 0) SendHTTPResponse(c, 200, html, F("File Uploaded successfully"), 1000);
  else {
    SPIFFS.remove(path);
    SendHTTPResponse(c, 500, html, F("File upload FAILED!!!"));
  }
}
//------------------------------------------
//Receive and Write Firmware
void WebCore::WriteFirmware(long fileSize, WiFiClient c) {

  Serial.println(F("-Firmware Update Start-"));

  char reqBuf[1024];

  //begin Firmware Update process passing filesize
  if (!Update.begin(fileSize, U_FLASH)) {
    //if begin failed
    SendHTTPResponse(c, 500, html, F("Firmware Update Error : Begin failed"));
    return;
  }

  //while some byte need to be written
  while (fileSize > 0) {

    //define number of byte to read
    size_t len = (fileSize >= sizeof(reqBuf)) ? sizeof(reqBuf) : fileSize;

    //wait for enough byte in c buffer
    int waited = 1000;
    while (c.available() < len && waited--) delay(1);

    //if waited more than 1 second
    if (!waited) {
      //then fail
      SendHTTPResponse(c, 500, html, F("Firmware Update Error : Network Timeout"));
      Update.end();
      return;
    }

    //else we have enough byte in c buffer
    //read
    c.read((uint8_t*)reqBuf, len);
    //write
    Update.write((uint8_t*)reqBuf, len);
    //decrement fileSize
    fileSize -= len;
  }

  //if Update successfully end
  if (Update.end()) {
    //send success message then restart
    SendHTTPResponse(c, 200, html, F("Firmware Successfully Uploaded"), 10000);
    Serial.println(F("-Firmware Update Ended Successfully -> Reboot-"));
    yield();
    ESP.restart();
  }
  else {
    //Update.end failed
    SendHTTPResponse(c, 500, html, F("Firmware Update Error : End failed"));
  }
}
//------------------------------------------
//Delete file based on passed filename
void WebCore::DeleteFile(String &filename, WiFiClient c) {

  //can't remove folder for the moment (answer already handle by GetRemoveFile (400 Error))
  if (filename[filename.length() - 1] == '/') return;

  //if file doesn't exists (answer already handle by GetRemoveFile (400 Error))
  if (!SPIFFS.exists(filename)) return;

  if (SPIFFS.remove(filename)) {
    SendHTTPResponse(c, 200, html, F("File Deleted successfully"));
  }
  else {
    SendHTTPResponse(c, 500, html, F("Deletion FAILED!!!"));
  }
}









//------------------------------------------
/*
  void handleOTAPassword(WiFiClient c, String req) {

  //check request structure
  if (req.indexOf('?') == -1 || req.indexOf(F("? ")) != -1 || req.indexOf(F(" HTTP/")) == -1) {
    strcpy_P(buf, PSTR("HTTP/1.1 400 missing parameter\r\n\r\n"));
    c.write((uint8_t *)buf, strlen(buf));
    return;
  }
  //keep only the part after '?' and before the final HTTP/1.1
  String getDatas = req.substring(req.indexOf('?') + 1, req.indexOf(F(" HTTP/")));

  String OTAPassword = findParameterInURLEncodedDatas(getDatas, F("pass"));

  if (OTAPassword.length() > 24) {
    strcpy_P(buf, PSTR("HTTP/1.1 400 Bad Request\r\n\r\n"));
    c.write((uint8_t *)buf, strlen(buf));
    return;
  }

  strcpy(config.otaPassword, OTAPassword.c_str());

  strcpy_P(buf, PSTR("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nExpires: 0\r\nConnection: close\r\n\r\nOK<script>setTimeout(function(){document.location=\"/config\";},1500);</script>"));
  c.write((uint8_t *)buf, strlen(buf));
  }
*/

