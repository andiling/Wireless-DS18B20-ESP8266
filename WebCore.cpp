#include <Arduino.h> //for byte type
#include <ESP8266WiFi.h>
#include <FS.h>

#include "WirelessDS18B20.h"

#include "WebCore.h"



//------------------------------------------
//simple function that convert an hexadecimal char to byte
byte WebCore::AsciiToHex(char c) {
  return (c < 0x3A) ? (c - 0x30) : (c > 0x60 ? c - 0x57 : c - 0x37);
}

//------------------------------------------
// Function that lookup in Datas to find a parameter and then return the corresponding decoded value
String WebCore::FindParameterInURLEncodedDatas(String datas, String parameterToFind) {

  String res = "";

  //can we find the param in the url
  int posParam = datas.indexOf(parameterToFind + "=");

  //if not then return empty string
  if (posParam == -1) return res;

  //if previous char is not a separator then lookup for the next match
  if (posParam != 0 && datas[posParam - 1] != '&') return FindParameterInURLEncodedDatas(datas.substring(posParam + parameterToFind.length()), parameterToFind);

  //now we can extract the value and decode it at the same time
  //adujst position to the start of the value
  posParam += parameterToFind.length() + 1;
  while (posParam < datas.length() && datas[posParam] != '&') {
    if (datas[posParam] == '+') res += ' ';
    else if (datas[posParam] == '%') {
      res += (char)(AsciiToHex(datas[posParam + 1]) * 0x10 + AsciiToHex(datas[posParam + 2]));
      posParam++;
      posParam++;
    }
    else res += datas[posParam];
    posParam++;
  }
  return res;
}
//------------------------------------------
//function that send to Web Client a standard answer (like error or simple success)
void WebCore::SendHTTPShortAnswer(WiFiClient c, int code, ContentType ct, String content, int goToRefererTimeOut) {
  strcpy_P(buf, PSTR("HTTP/1.1 "));
  switch (code) {
    case 200:
      strcat_P(buf, PSTR("200 OK"));
      break;
    case 400:
      strcat_P(buf, PSTR("400 Bad Request"));
      break;
    case 404:
      strcat_P(buf, PSTR("404 Not Found"));
      break;
    case 500:
      strcat_P(buf, PSTR("500 Internal Server Error"));
      break;
    default:
      return; //other code not accepted yet
  }

  if (ct != no) {

    strcat_P(buf, PSTR("\r\nContent-Type: "));

    switch (ct) {
      case html:
        strcat_P(buf, PSTR("text/html"));
        break;
      case json:
        strcat_P(buf, PSTR("text/json"));
        break;
    }
  }
  sprintf_P(buf, PSTR("%s\r\nExpires: 0\r\nConnection: close\r\nContent-Length: %d\r\n\r\n"), buf, content.length() + (goToRefererTimeOut ? 103 + String(goToRefererTimeOut).length() : 0));
  c.write((uint8_t *)buf, strlen(buf));

  if (content != "" || goToRefererTimeOut) {
    strcpy(buf, content.c_str());
    if (goToRefererTimeOut) sprintf_P(buf, PSTR("%s<script>setTimeout(function(){if('referrer' in document)window.location=document.referrer;},%d);</script>"), buf, goToRefererTimeOut);
    c.write((uint8_t *)buf, strlen(buf));
  }
}


const PROGMEM bool gz = true;
const PROGMEM char fwhtmlgz[] = {0x1F,0x8B,0x08,0x08,0x4B,0x5E,0xA7,0x58,0x02,0x00,0x66,0x77,0x2E,0x68,0x74,0x6D,0x6C,0x00,0xBD,0x58,0xE9,0x8E,0xD3,0x30,0x10,0xFE,0x8F,0xC4,0x3B,0x98,0x00,0x72,0xC2,0xEE,0x26,0xB4,0x1C,0x82,0x5E,0x08,0x58,0x10,0x8B,0x38,0x55,0x10,0x42,0xC0,0x0F,0x37,0x99,0xB4,0x06,0xC7,0x09,0xB6,0xB3,0xA5,0x20,0xDE,0x9D,0xB1,0x93,0xA6,0x81,0x36,0x15,0x77,0x56,0xDB,0xFA,0x9C,0xF9,0xE6,0x9B,0xF1,0x8C,0xD3,0xD1,0xB9,0xE3,0xA7,0x77,0x5F,0xBC,0x7E,0x76,0x8F,0x2C,0x4C,0x26,0x26,0x67,0xCF,0x8C,0xEA,0x6F,0x82,0xCF,0x68,0x01,0x2C,0xA9,0xDB,0xAE,0x9F,0x81,0x61,0x24,0x5E,0x30,0xA5,0xC1,0x8C,0xBD,0xD2,0xA4,0x47,0x37,0xBC,0xF6,0xBC,0xE1,0x46,0xC0,0xE4,0xE1,0xF5,0x3B,0xE4,0x15,0x57,0x20,0x40,0x6B,0x72,0x3C,0xED,0xDD,0xB8,0xD3,0xBF,0x3C,0x8A,0xDC,0xDC,0x5A,0x70,0xD4,0x92,0x3C,0x9A,0xE5,0xC9,0x8A,0x68,0xB3,0x12,0x30,0xF6,0x66,0x2C,0xFE,0x30,0x57,0x79,0x29,0x93,0xA3,0x38,0x17,0xB9,0x1A,0x90,0xF3,0x69,0x9A,0xCC,0x6E,0xDE,0x1C,0x92,0xBB,0x75,0xFF,0xB2,0x7B,0x86,0x69,0x2E,0xCD,0x51,0xCA,0x32,0x2E,0x56,0x03,0x72,0x5B,0x71,0x26,0x86,0xDF,0x61,0x59,0xF4,0x3A,0x80,0xE0,0x44,0x7B,0x59,0x7F,0xAD,0x3A,0xE1,0xBA,0x10,0x6C,0x35,0xE0,0x52,0x70,0x09,0xDE,0xE4,0x3E,0x57,0xD9,0x92,0x29,0x20,0x8F,0x99,0x64,0x73,0xC8,0x40,0x1A,0xF2,0x0C,0x1B,0x28,0xA1,0x3F,0x19,0xE9,0x82,0x49,0xC2,0x93,0xB1,0x27,0x7A,0xDE,0x64,0x8F,0x94,0xD1,0x6C,0x42,0x1E,0xE5,0x2C,0xE1,0x72,0x1E,0x86,0xE1,0x28,0x9A,0x4D,0xAA,0xFD,0x91,0x15,0x80,0x40,0xDA,0x50,0xAE,0x4C,0x5E,0x16,0x02,0xD7,0x12,0x46,0x24,0x2C,0x49,0x03,0x60,0x60,0x09,0xBB,0xD2,0x46,0x9D,0xE6,0x2A,0x73,0xDA,0xD3,0x9E,0x47,0xD0,0x2B,0x8B,0x3C,0x19,0xD3,0x67,0x4F,0xA7,0x2F,0x28,0x61,0xB1,0xE1,0xB9,0x1C,0xD3,0x28,0x5D,0x52,0x02,0x32,0x36,0xAB,0x02,0xC6,0x34,0x2B,0x85,0xE1,0x05,0x53,0x26,0xB2,0x5B,0x8F,0x12,0x66,0x18,0x25,0xB9,0xD4,0xE5,0x2C,0xE3,0x66,0x4C,0x15,0x98,0x52,0x49,0x12,0xE7,0x32,0x45,0xA5,0xBE,0x77,0x1B,0xB5,0xAE,0xF2,0x92,0xE8,0x12,0x1B,0x26,0x27,0xA9,0x60,0x7A,0x41,0xD2,0x1A,0xD0,0x2D,0x2F,0x18,0xD2,0x1A,0x4E,0x03,0x89,0xCB,0xA2,0x34,0xA4,0xD2,0x96,0x72,0x01,0x94,0x48,0x96,0xB9,0x76,0x8F,0x22,0x54,0x6C,0xF4,0x2C,0xB8,0x18,0x0A,0xD4,0x17,0xCE,0xB8,0xDC,0x2B,0xA1,0x02,0x46,0xC9,0x29,0x13,0x25,0x76,0xA3,0x73,0x6F,0x49,0xC5,0xCD,0x86,0x15,0x1C,0xA3,0xE4,0x07,0x19,0x8D,0x5B,0xA8,0xEA,0xD1,0x0D,0xC9,0xCD,0xB4,0xB3,0xBE,0x9B,0xF5,0x57,0x30,0x43,0xF9,0x62,0x1F,0xE3,0x34,0xED,0xD3,0x2E,0xC6,0xCB,0x62,0x3F,0xE3,0xBF,0xC0,0x59,0xDF,0x72,0xE6,0x1A,0xBF,0x42,0x53,0x43,0x11,0x8A,0xEA,0x66,0xA6,0xDF,0xCD,0xCC,0x66,0xA0,0x35,0x35,0x53,0x13,0xFC,0xC7,0xB9,0x6D,0x59,0xC9,0x4A,0x4E,0xB1,0x4D,0xEB,0xE8,0xA7,0xEB,0xE8,0x27,0x32,0x97,0xB0,0x15,0x23,0xD3,0x67,0x27,0xF7,0xEF,0x4F,0x49,0xA9,0x21,0x89,0x4C,0x6E,0x98,0x20,0x9A,0x7F,0x46,0xB2,0x5B,0x02,0xCB,0x06,0x1B,0x89,0x5A,0xC3,0xA6,0x19,0xDE,0x20,0x69,0x7B,0xD0,0x39,0x4D,0x70,0x6D,0xC8,0x60,0xB3,0x49,0xF4,0x69,0xFB,0xEC,0xD5,0x02,0x5A,0x8E,0xDD,0xE4,0x2D,0x36,0x13,0x50,0x11,0x2E,0xAC,0x26,0xD7,0x6F,0x2D,0xDA,0x75,0x5A,0x75,0xAC,0x78,0x61,0x88,0x56,0xF1,0xD8,0x8B,0xDE,0x7F,0x2C,0x41,0xAD,0x8E,0xAE,0x84,0x3D,0xFC,0xCB,0xB8,0x0C,0xDF,0x6B,0xAF,0x72,0x91,0x67,0xE0,0x93,0x89,0xDE,0xB3,0x53,0x56,0x6D,0xF0,0x50,0x7C,0xD5,0x9A,0x6C,0x09,0xFB,0x01,0x16,0x4F,0x89,0x7F,0x6E,0xC9,0x65,0x92,0x2F,0xC3,0xF7,0xCF,0xAD,0x82,0xE0,0x4B,0xB3,0xA2,0x79,0x92,0x3C,0x2E,0x6D,0x6E,0x0A,0x97,0x8A,0x1B,0xF0,0x69,0x2D,0xAB,0x43,0x7B,0x85,0x77,0x61,0x4C,0xA1,0x07,0x51,0xC4,0xDE,0xB3,0x4F,0x21,0xD3,0x85,0x04,0x13,0x27,0x32,0x8C,0xF3,0xCC,0x0D,0x45,0x95,0xB6,0x5D,0x56,0x21,0xFC,0xB7,0x6B,0xFC,0x34,0x18,0xEE,0x81,0x33,0x07,0x73,0x4F,0x80,0x6D,0xDE,0x59,0x9D,0x24,0x3E,0x15,0x3D,0x1A,0x84,0x5C,0x4A,0x50,0x0F,0x5E,0x3C,0x7E,0x34,0xA6,0xA3,0xC5,0xD5,0xAE,0x9C,0x49,0xFC,0x87,0x0E,0x00,0xB1,0xD1,0x0C,0x09,0x49,0x55,0x9E,0x91,0x13,0x69,0x40,0x21,0xD0,0x00,0x1D,0x78,0x75,0x42,0x7F,0x50,0xFD,0xF5,0xFB,0x2E,0x08,0x0D,0xE4,0x82,0xEF,0x9D,0xC7,0xEC,0x1C,0x84,0x29,0x4A,0x79,0x5A,0x1A,0xBF,0x8D,0xF7,0x4F,0xBC,0x40,0xBE,0xFC,0x2B,0xBB,0xEF,0xDC,0x9E,0x9E,0xDC,0x25,0x8F,0x9F,0x1E,0xDF,0xDB,0x32,0xB3,0x79,0x98,0x00,0x65,0x7C,0xDA,0xA2,0x88,0xA4,0x8C,0x0B,0x48,0x42,0xF2,0xF2,0x84,0x70,0x4D,0xB8,0x24,0x33,0xA6,0x79,0x4C,0xB2,0x3C,0x81,0x90,0x06,0x9D,0x54,0xED,0x27,0xE1,0xFB,0x5D,0x69,0x29,0x5D,0x9A,0x23,0x0A,0x52,0x05,0x7A,0x71,0xFF,0x91,0xBF,0x2B,0x1A,0xB7,0x47,0x9C,0x17,0xFA,0xB5,0x17,0x4E,0x24,0x3A,0x61,0xF7,0x9A,0x54,0xE0,0x1A,0x7B,0xF9,0xC0,0x10,0x36,0x98,0x71,0xCC,0xC2,0xD6,0x4E,0x9B,0x15,0x6D,0x4E,0xAC,0x0A,0x27,0x8E,0xD5,0xE3,0x98,0x38,0x7E,0x18,0x8B,0xDC,0x07,0xEE,0xA4,0x3B,0x35,0x58,0xBF,0x3C,0x9C,0x3E,0x7D,0xE2,0x7B,0x11,0x6A,0x3A,0x6C,0xEC,0xF1,0x6D,0xEA,0x78,0xC4,0xB5,0x41,0x6B,0x6A,0x93,0xB7,0xF7,0x02,0x8B,0x17,0xCD,0xC2,0xC3,0x66,0xEB,0x87,0xC3,0xD3,0x6D,0x0E,0xDA,0x91,0xE3,0x7F,0x38,0xE7,0x52,0x4A,0x80,0x16,0xD2,0xF3,0xF4,0xE0,0x43,0x6D,0xE1,0xE9,0x36,0xC4,0xDA,0x37,0x5D,0x13,0x3F,0x85,0x2C,0x4C,0xC5,0x06,0x1C,0xDF,0x0B,0x6E,0x43,0x39,0x2B,0x0A,0x90,0x89,0xEF,0xAD,0x49,0xF7,0x0E,0x4E,0x43,0x79,0xE0,0x59,0x3E,0x9B,0xBE,0x6E,0xF5,0xBF,0xAB,0x3F,0xB3,0xD2,0x98,0x5C,0xD2,0xAA,0x16,0xCC,0xBC,0x03,0x7E,0xE0,0x35,0xC5,0xE8,0x18,0x04,0x18,0xA0,0x1B,0xCF,0xB8,0xDC,0x8D,0x57,0x87,0xFD,0xA0,0x9C,0x98,0x20,0x8C,0x05,0x8F,0x3F,0xF8,0x8D,0x35,0x70,0x6A,0x3A,0xAD,0x69,0xBB,0xD8,0xA7,0x91,0xCA,0x6E,0x61,0x31,0x3E,0x00,0x1D,0xB3,0x02,0x7C,0x34,0x26,0x40,0x23,0xC5,0x92,0xAD,0xB4,0xDF,0xC4,0xEE,0x3E,0x10,0x5F,0x7F,0xD9,0x39,0x9B,0x10,0xDF,0x4E,0x34,0xDD,0xBB,0xBF,0x0E,0x3B,0xCF,0x58,0x55,0xC7,0x9F,0xA9,0x7C,0x8E,0x70,0x11,0x76,0x97,0xE9,0xA7,0x4C,0x91,0x4F,0x0B,0x45,0xC6,0x68,0xBC,0x4D,0xDC,0x53,0x30,0x06,0x8B,0x9D,0x0E,0x71,0xD0,0x0F,0x48,0x07,0x5C,0x9C,0x0C,0x4B,0xA7,0x21,0xCC,0x65,0x51,0x2B,0x41,0x19,0xDF,0x93,0x4D,0x54,0x7D,0x1A,0x4F,0x24,0x59,0x23,0xC1,0xA3,0x85,0x51,0x6D,0xE7,0x43,0x01,0x72,0x6E,0x16,0x77,0xF3,0xAC,0x28,0x5D,0xB5,0xC4,0xA4,0xA8,0xD6,0xB1,0x44,0xB1,0xA4,0xD3,0x03,0xB7,0xCA,0x25,0xF0,0xC8,0x36,0x5D,0xC1,0xBF,0xD4,0xBB,0x7C,0xF9,0x80,0x5E,0x44,0x39,0x5F,0x87,0xE4,0x6B,0x17,0xC0,0xFA,0x36,0x8A,0x38,0xBB,0x28,0xDB,0x84,0xB0,0xCD,0xEF,0xD5,0x2D,0x68,0x6F,0xB0,0x58,0x04,0x85,0x82,0x53,0x90,0xE6,0x18,0x52,0x56,0x8A,0x2D,0x27,0xD5,0x14,0xFA,0x3B,0xA8,0x2E,0x95,0x18,0xB8,0xFB,0xF4,0xA1,0x8D,0xFA,0x41,0x75,0xED,0x3B,0x8C,0xF1,0xE8,0xC1,0x80,0xA4,0x4C,0x68,0x38,0x8C,0x73,0x69,0x50,0xF6,0x8B,0x55,0xD1,0x0C,0x21,0xB3,0x31,0x72,0x76,0xCC,0x0C,0x5B,0x0F,0xED,0x28,0x1B,0x76,0xD6,0x5D,0xF6,0x73,0x95,0xD9,0xA5,0xBE,0xCD,0x14,0x29,0xD6,0x8C,0x37,0x97,0xDF,0x05,0xDB,0x1B,0x2C,0x29,0x83,0x8D,0xA7,0x82,0x2F,0x8E,0xAB,0xAD,0x88,0xB1,0x42,0x14,0x0A,0x41,0x9E,0x77,0xC8,0xD0,0x65,0x6C,0x91,0x0D,0x1A,0x31,0xC9,0xA1,0xDE,0x17,0x62,0x0A,0xAC,0xF0,0xDE,0x35,0x0D,0xF1,0xB8,0xA9,0x73,0xB1,0x02,0x66,0xA0,0x2E,0x75,0x3E,0xAD,0xCA,0x06,0xED,0x38,0x22,0x6D,0x11,0xA1,0xBD,0x93,0x8C,0xA9,0x15,0x1C,0xE7,0xA5,0x34,0xE3,0xDE,0xD5,0xA1,0xEB,0x24,0x7C,0xAC,0xC1,0xB8,0x3A,0x8F,0x29,0xC4,0x6F,0x19,0x69,0x3D,0x1D,0x27,0x5E,0xE0,0xB6,0xFA,0x6E,0x57,0x30,0xC4,0x40,0x3C,0x57,0x35,0xBF,0xC4,0x02,0x98,0x6A,0x36,0xA2,0xA0,0x60,0x28,0xF2,0x98,0xD9,0xDD,0x61,0xA5,0xD9,0x47,0x26,0xDC,0xE2,0xA3,0x23,0xA4,0x04,0xA3,0xF0,0x72,0x30,0xA4,0x1D,0x58,0x6B,0xF2,0x9A,0x6A,0xE4,0x2E,0x94,0x75,0xC9,0xAE,0x5F,0x4A,0x91,0x65,0x90,0x43,0xF7,0x76,0x77,0x9C,0x4B,0x5B,0x89,0x9A,0x6B,0xEB,0x74,0xA5,0x0D,0x64,0xB6,0x0E,0x2B,0x98,0xE5,0xB9,0xB1,0x97,0x4F,0xF2,0x62,0x81,0xFD,0x82,0xCD,0x81,0x2C,0xB9,0x10,0x64,0x06,0x35,0x21,0x90,0xD8,0x6A,0xBD,0x79,0x99,0x44,0x23,0x27,0xBD,0x6B,0xB5,0x28,0xCB,0x15,0x6D,0x12,0x74,0x8B,0xC1,0x2E,0x92,0xD7,0xA1,0x13,0x1A,0xC5,0xE7,0x73,0x50,0x3E,0x55,0xA0,0x61,0xB7,0x53,0x76,0xC5,0x05,0x28,0x85,0xC6,0xB5,0x78,0xFF,0x6D,0x7E,0x14,0x24,0x15,0x3B,0xF7,0xDD,0xCD,0xA4,0xC5,0x0F,0xFD,0x2B,0xE0,0x71,0xA8,0x23,0xB5,0x62,0x67,0x3B,0x49,0xF4,0xFF,0x5A,0x92,0x70,0xB6,0xF7,0x11,0x25,0x64,0x85,0x59,0xF9,0x28,0x76,0x91,0x2F,0xDD,0xAA,0x5F,0x4B,0x26,0x65,0xF1,0xFF,0x92,0x49,0xFF,0x6F,0x24,0x93,0xFE,0x9F,0x26,0x93,0x0D,0x7B,0xBF,0x79,0xB2,0xE8,0xA6,0xBE,0x5E,0xC3,0xF3,0xBB,0x37,0x8E,0xFA,0x5D,0x71,0xB4,0xFD,0x6C,0xEE,0xB3,0xFF,0xE2,0x98,0xF4,0x7F,0xE3,0x98,0xFC,0xB9,0xB1,0x7F,0x7E,0x68,0xD6,0x69,0x3E,0x08,0x15,0xB0,0x64,0xE5,0x77,0x59,0xEB,0xCE,0x57,0xFD,0x2B,0x40,0xC7,0x1D,0xBF,0x93,0x63,0xA7,0xB4,0xF3,0x65,0x04,0xC9,0xC8,0x93,0x15,0x76,0x46,0x91,0x25,0x70,0xF2,0x0D,0xBE,0x64,0x92,0xFD,0xAA,0x14,0x00,0x00};
//------------------------------------------
//native webpage that implement Firmware Update and file management
void WebCore::GetFirmwarePage(WiFiClient c) {
  //send header
  strcpy_P(buf, PSTR("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nExpires: 0\r\n"));
  if (gz) strcat_P(buf, PSTR("Content-Encoding: gzip\r\n"));
  strcat_P(buf, PSTR("\r\n"));
  c.write((uint8_t *)buf, strlen(buf));
  //send native firmware page
  c.write_P(fwhtmlgz, sizeof(fwhtmlgz));
}
//------------------------------------------
//Provide a JSON list of file and infos about FS
void WebCore::GetFileList(WiFiClient c) {

  FSInfo fs_info;
  SPIFFS.info(fs_info);

  String flJSON = String(F("{\"t\":")) + fs_info.totalBytes + F(",\"u\":") + fs_info.usedBytes + F(",\"fl\":[");

  Dir dir = SPIFFS.openDir("/");
  bool first = true;

  while (dir.next()) {

    File entry = dir.openFile("r");
    flJSON += String(!first ? "," : "") + F("{\"t\":\"f\",\"n\":\"") + entry.name() + F("\",\"s\":") + entry.size() + F("}");
    entry.close();
    first = false;
  }
  flJSON += F("]}");

  SendHTTPShortAnswer(c, 200, json, flJSON);
}
//------------------------------------------
//Parse GET request then call handleFileRead to return the file to Web Client
void WebCore::GetFile(WiFiClient c, String req) {
  req = req.substring(4, req.indexOf(F(" HTTP/1."))); //isolate filename
  req.replace(F("%20"), " "); //only url encoded space is accepted
  ReadFile(req, c);
}

//------------------------------------------
//Manage HTTP discussion in order to receive a POSTed file
void WebCore::PostFile(WiFiClient c, bool firmwareUpdate) {
  String tmp = "";
  String header = "";
  byte boundarySize = 0;
  int i, j;
  long contentLength = 0;
  String filename = "";


  //read complete header (until empty line is found) -----
  tmp = c.readStringUntil('\n');
  while (tmp != "\r") {
    header += tmp;
    tmp = c.readStringUntil('\n');
  }

  //find boundary then it's size
  i = header.indexOf(F("boundary=")) + 9;
  j = i;
  while (header[j] != '\r' && j < header.length()) j++;
  boundarySize = j - i;


  //find Content-Length and extract it (converted to long)
  i = header.indexOf(F("Content-Length")) + 14;
  if (header[i] == ' ' || header[i] == ':') i++;
  if (header[i] == ' ' || header[i] == ':') i++;
  j = i;
  while (header[j] >= '0' && header[j] <= '9' && j < header.length()) j++;
  tmp = header.substring(i, j);
  contentLength = tmp.toInt();

  //end of page is marked with a CRLF, boundary with 4 minuses and another CRLF
  contentLength -= boundarySize + 2 + 4 + 2;

  //check for empty POST
  if (contentLength <= 0) {
    SendHTTPShortAnswer(c, 400, html, F("Missing File Content!"));
    return;
  }

  //read complete boundary header (until empty line is found) -----
  tmp = c.readStringUntil('\n');
  contentLength -= tmp.length() + 1;
  while (tmp != "\r") {
    header += tmp;
    tmp = c.readStringUntil('\n');
    contentLength -= tmp.length() + 1;
  }

  if (!firmwareUpdate) {

    //look for filename
    i = header.indexOf("filename=") + 9;
    if (header[i] == '\"') i++;
    j = i;
    while (header[j] != '\"' && header[j] != '\r' && j < header.length()) j++;
    filename = header.substring(i, j);

    if (filename[0] != '/') filename = "/" + filename; //if first / is missing

    if (SPIFFS.exists(filename)) {
      SendHTTPShortAnswer(c, 400, html, F("File Already exists"));
      return;
    }

    FSInfo fs_info;
    SPIFFS.info(fs_info);
    if (fs_info.totalBytes <= (fs_info.usedBytes + contentLength + 64)) {
      while (contentLength) {
        c.read(); //waste datas
        contentLength--;
      };
      SendHTTPShortAnswer(c, 400, html, F("Not enough place on destination storage"));
      return;
    }
  }

  //empty String
  header = String();
  tmp = String();

  if (firmwareUpdate) WriteFirmware(contentLength, c);
  else WriteFile(filename, contentLength, c);
}
//------------------------------------------
//Parse GET request to remove a file
void WebCore::GetRemoveFile(WiFiClient c, String req) {

  String tmp = "";
  String header = "";
  int i, j;

  //check request structure
  if (req.indexOf('?') == -1 || req.indexOf(F("? ")) != -1 || req.indexOf(F(" HTTP/")) == -1) {
    SendHTTPShortAnswer(c, 400, html, F("Missing parameter"));
    return;
  }
  //keep only the part after '?' and before the final HTTP/1.1
  String getDatas = req.substring(req.indexOf('?') + 1, req.indexOf(F(" HTTP/")));

  String filename = FindParameterInURLEncodedDatas(getDatas, F("n"));

  //check filename passed
  if (filename[filename.length() - 1] == '/') {
    SendHTTPShortAnswer(c, 400, html, F("Can't Remove Folder"));
    return;
  }

  //check that file exists
  if (!SPIFFS.exists(filename)) {
    SendHTTPShortAnswer(c, 400, html, F("This file does not exist"));
    return;
  }

  //read complete header (until empty line is found) ---
  tmp = c.readStringUntil('\n');
  while (tmp != "\r") {
    header += tmp;
    tmp = c.readStringUntil('\n');
  }

  //empty String
  header = String();
  tmp = String();

  DeleteFile(filename, c);
}

//------------------------------------------
//Return Content-Type based on filename
String WebCore::getContentType(String filename) {
  /*if (server.hasArg("download")) return F("application/octet-stream");
    else */if (filename.endsWith(".htm")) return F("text/html");
  else if (filename.endsWith(".html")) return F("text/html");
  else if (filename.endsWith(".css")) return F("text/css");
  else if (filename.endsWith(".js")) return F("application/javascript");
  //else if (filename.endsWith(".png")) return F("image/png");
  //else if (filename.endsWith(".gif")) return F("image/gif");
  //else if (filename.endsWith(".jpg")) return F("image/jpeg");
  else if (filename.endsWith(".ico")) return F("image/x-icon");
  //else if (filename.endsWith(".xml")) return F("text/xml");
  //else if (filename.endsWith(".pdf")) return F("application/x-pdf");
  //else if (filename.endsWith(".zip")) return F("application/x-zip");
  else if (filename.endsWith(".gz")) return F("application/x-gzip");
  return F("text/plain");
}
//------------------------------------------
//Open the file then return content to Web Client
void WebCore::ReadFile(String path, WiFiClient c) {

  //if (path.endsWith("/")) path += "index.htm";
  //if no extension then add .html
  if (path.indexOf('.') == -1) path += F(".html");
  String contentType = getContentType(path);
  size_t sent = 0;
  if (SPIFFS.exists(path) || SPIFFS.exists(path + F(".gz"))) {
    if (SPIFFS.exists(path + F(".gz"))) path += F(".gz");

    File file = SPIFFS.open(path, "r");
    if (file) {

      //prepare and send header
      strcpy_P(buf, PSTR("HTTP/1.1 200 OK\r\nContent-Type: "));
      strcat(buf, contentType.c_str());
      if (String(file.name()).endsWith(".gz") && contentType != "application/x-gzip" && contentType != "application/octet-stream") {
        strcat_P(buf, PSTR("\r\nContent-Encoding: gzip"));
      }
      strcat_P(buf, PSTR("\r\n\r\n"));
      c.write((uint8_t *)buf, strlen(buf));


      int siz = file.size();
      while (siz > 0) {
        size_t len = std::min((int)(sizeof(buf) - 1), siz);
        file.read((uint8_t *)buf, len);
        sent += c.write((uint8_t *)buf, len);
        siz -= len;
      }

      //sent = c.write(file);
      file.close();
    }
  }

  if (sent == 0) {
    SendHTTPShortAnswer(c, 404);
  }
}

//------------------------------------------
//Create file and fill it with Web Client datas
void WebCore::WriteFile(String path, long fileSize, WiFiClient c) {


  File fsUploadFile = SPIFFS.open(path, "w");

  while (fileSize > 0) {
    size_t len = (fileSize >= sizeof(buf)) ? sizeof(buf) : fileSize;

    //wait for enough byte in c buffer
    int waited = 1000;
    while (c.available() < len && waited--) delay(1);

    //if waited more than 1 second
    if (!waited) {
      //then fail
      SendHTTPShortAnswer(c, 500, html, F("File Upload Error : Network Timeout"));
      fsUploadFile.close();
      SPIFFS.remove(path);
      return;
    }


    c.read((uint8_t*)buf, len);
    fsUploadFile.write((uint8_t*)buf, len);
    fileSize -= len;
  }
  fsUploadFile.close();

  if (fileSize == 0) SendHTTPShortAnswer(c, 200, html, F("File Uploaded successfully"), 1000);
  else {
    SPIFFS.remove(path);
    SendHTTPShortAnswer(c, 500, html, F("File upload FAILED!!!"));
  }
}
//------------------------------------------
//Receive and Write Firmware
void WebCore::WriteFirmware(long fileSize, WiFiClient c) {

  Serial.println(F("-Firmware Update Start-"));

  //begin Firmware Update process passing filesize
  if (!Update.begin(fileSize, U_FLASH)) {
    //if begin failed
    SendHTTPShortAnswer(c, 500, html, F("Firmware Update Error : Begin failed"));
    return;
  }

  //while some byte need to be written
  while (fileSize > 0) {

    //define number of byte to read
    size_t len = (fileSize >= sizeof(buf)) ? sizeof(buf) : fileSize;

    //wait for enough byte in c buffer
    int waited = 1000;
    while (c.available() < len && waited--) delay(1);

    //if waited more than 1 second
    if (!waited) {
      //then fail
      SendHTTPShortAnswer(c, 500, html, F("Firmware Update Error : Network Timeout"));
      Update.end();
      return;
    }

    //else we have enough byte in c buffer
    //read
    c.read((uint8_t*)buf, len);
    //write
    Update.write((uint8_t*)buf, len);
    //decrement fileSize
    fileSize -= len;
  }

  //if Update successfully end
  if (Update.end()) {
    //send success message then restart
    SendHTTPShortAnswer(c, 200, html, F("Firmware Successfully Uploaded"), 10000);
    Serial.println(F("-Firmware Update Ended Successfully -> Reboot-"));
    yield();
    ESP.restart();
  }
  else {
    //Update.end failed
    SendHTTPShortAnswer(c, 500, html, F("Firmware Update Error : End failed"));
  }
}
//------------------------------------------
//Delete file based on passed filename
void WebCore::DeleteFile(String filename, WiFiClient c) {

  //can't remove folder for the moment (answer already handle by GetRemoveFile (400 Error))
  if (filename[filename.length() - 1] == '/') return;

  //if file doesn't exists (answer already handle by GetRemoveFile (400 Error))
  if (!SPIFFS.exists(filename)) return;

  if (SPIFFS.remove(filename)) {
    SendHTTPShortAnswer(c, 200, html, F("File Deleted successfully"), 1000);
  }
  else {
    SendHTTPShortAnswer(c, 500, html, F("Deletion FAILED!!!"));
  }
}









//------------------------------------------
/*
  void handleOTAPassword(WiFiClient c, String req) {

  //check request structure
  if (req.indexOf('?') == -1 || req.indexOf(F("? ")) != -1 || req.indexOf(F(" HTTP/")) == -1) {
    strcpy_P(buf, PSTR("HTTP/1.1 400 missing parameter\r\n\r\n"));
    c.write((uint8_t *)buf, strlen(buf));
    return;
  }
  //keep only the part after '?' and before the final HTTP/1.1
  String getDatas = req.substring(req.indexOf('?') + 1, req.indexOf(F(" HTTP/")));

  String OTAPassword = findParameterInURLEncodedDatas(getDatas, F("pass"));

  if (OTAPassword.length() > 24) {
    strcpy_P(buf, PSTR("HTTP/1.1 400 Bad Request\r\n\r\n"));
    c.write((uint8_t *)buf, strlen(buf));
    return;
  }

  strcpy(config.otaPassword, OTAPassword.c_str());

  strcpy_P(buf, PSTR("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nExpires: 0\r\nConnection: close\r\n\r\nOK<script>setTimeout(function(){document.location=\"/config\";},1500);</script>"));
  c.write((uint8_t *)buf, strlen(buf));
  }
*/

